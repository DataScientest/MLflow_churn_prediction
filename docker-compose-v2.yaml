services:
  # PostgreSQL Backend Store for MLflow
  postgres:
    image: postgres:15
    container_name: mlflow_postgres
    environment:
      POSTGRES_USER: mlflow
      POSTGRES_PASSWORD: mlflow
      POSTGRES_DB: mlflow
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U mlflow"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Pipeline Runner (for training/evaluation/registration)
  pipeline-runner:
    build:
      context: .
      dockerfile: Dockerfile
    image: churn-prediction-env
    container_name: churn_pipeline_runner
    volumes:
      - ./mlruns:/app/mlruns
      - ./data:/app/data
    environment:
      - MLFLOW_TRACKING_URI=postgresql://mlflow:mlflow@postgres:5432/mlflow
    command: python src/pipeline.py
    depends_on:
      postgres:
        condition: service_healthy

  # Image Builder (builds immutable model image inside the container)
  image-builder:
    build:
      context: .
      dockerfile: Dockerfile
    image: churn-prediction-env
    container_name: churn_image_builder
    volumes:
      - //var/run/docker.sock:/var/run/docker.sock  # Mount host Docker socket (note the extra slash for Windows compatibility)
      - ./mlruns:/app/mlruns
    environment:
      - MLFLOW_TRACKING_URI=postgresql://mlflow:mlflow@postgres:5432/mlflow
    command: python src/build_model_image.py
    depends_on:
      postgres:
        condition: service_healthy

  # Production Model Server (using baked image)
  # NOTE: This service expects the 'churn-model:production' image to exist
  # Run 'docker compose -f docker-compose-v2.yaml run --rm image-builder' first to create it
  production-server:
    image: churn-model:production
    container_name: churn_production_server
    ports:
      - "5000:8080"
    # No volumes needed - model is baked into the image!
    # No database needed - completely self-contained!

volumes:
  postgres_data:
